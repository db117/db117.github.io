import{_ as a,c as t,a3 as r,o as i}from"./chunks/framework.CuBk2nsQ.js";const p=JSON.parse('{"title":"AbstractQueuedSynchronizer相关","description":"","frontmatter":{"title":"AbstractQueuedSynchronizer相关"},"headers":[],"relativePath":"java/concurrent/AbstractQueuedSynchronizer.md","filePath":"java/concurrent/AbstractQueuedSynchronizer.md"}'),n={name:"java/concurrent/AbstractQueuedSynchronizer.md"};function o(l,e,c,d,s,u){return i(),t("div",null,e[0]||(e[0]=[r('<hr><h2 id="reentrantreadwritelock" tabindex="-1">ReentrantReadWriteLock <a class="header-anchor" href="#reentrantreadwritelock" aria-label="Permalink to &quot;ReentrantReadWriteLock&quot;">​</a></h2><blockquote><p>读写锁，适合读多写少的场景</p><p>使用 Sync ( 实际是 AQS )的 int 类型的 state 来表示同步状态，维护着一对读写锁，如果要用一个变量维护多种状态，需要采用“按位切割使用”的方式来维护这个变量，将其切分为两部分：高16为表示读，低16为表示写。</p></blockquote><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ul><li>读写互斥</li><li>写写互斥</li><li>可重入</li><li>支持公平与非公平</li><li>支持条件队列</li><li>提供一下锁状态监控api</li><li>读锁不支持等待队列</li><li>重入不能升级，持有读锁的情况下去获取写锁会导致获取永久等待</li><li>可支持锁降级，在获取写锁时获取读锁、然后释放写锁，则降级为读锁</li></ul><h4 id="读写锁流程图" tabindex="-1">读写锁流程图 <a class="header-anchor" href="#读写锁流程图" aria-label="Permalink to &quot;读写锁流程图&quot;">​</a></h4>',6)]))}const b=a(n,[["render",o]]);export{p as __pageData,b as default};
