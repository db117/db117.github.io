import{_ as o,c as l,o as a,m as e,a as t,U as c}from"./chunks/framework.L6XTt9Gt.js";const f=JSON.parse('{"title":"线程池","description":"","frontmatter":{"title":"线程池"},"headers":[],"relativePath":"java/concurrent/ThreadPool.md","filePath":"java/concurrent/ThreadPool.md","lastUpdated":1704353670000}'),u={name:"java/concurrent/ThreadPool.md"},d=e("h3",{id:"线程池流程图",tabindex:"-1"},[t("线程池流程图 "),e("a",{class:"header-anchor",href:"#线程池流程图","aria-label":'Permalink to "线程池流程图"'},"​")],-1),r=e("iframe",{id:"embed_dom",name:"embed_dom",frameborder:"0",style:{display:"block",width:"725px",height:"245px"},src:"https://www.processon.com/embed/619f50e40e3e743d103b520d"},null,-1),i=e("iframe",{id:"embed_dom",name:"embed_dom",frameborder:"0",style:{display:"block",width:"725px",height:"245px"},src:"https://www.processon.com/embed/61a48efa1efad425fd73dce4"},null,-1),p=c('<h3 id="关键属性" tabindex="-1">关键属性 <a class="header-anchor" href="#关键属性" aria-label="Permalink to &quot;关键属性&quot;">​</a></h3><ul><li><p>ctl</p><blockquote><p>使用高 2 位保存线程池运行状态，低 29 为保存运行线程数</p></blockquote></li><li><p>workQueue</p><blockquote><p>工作队列，保存需要运行的线程</p></blockquote></li><li><p>mainLock</p><blockquote><p>主锁，在修改一下核心属性是需要持有该锁</p></blockquote></li><li><p>largestPoolSize</p><blockquote><p>达到的最大线程数量，访问需要持有 <code>mainLock</code></p></blockquote></li><li><p>completedTaskCount</p><blockquote><p>完成任务的计数器。访问需要持有 <code>mainLock</code></p></blockquote></li><li><p>threadFactory</p><blockquote><p>线程工厂</p></blockquote></li><li><p>handler</p><blockquote><p>添加任务失败，或者强制结束线程是调用</p></blockquote></li><li><p>keepAliveTime</p><blockquote><p>工作线程允许空闲时间</p></blockquote></li><li><p>allowCoreThreadTimeOut</p><blockquote><p>是否允许核心线程超时，默认 false</p></blockquote></li><li><p>corePoolSize</p><blockquote><p>核心线程数量</p></blockquote></li><li><p>maximumPoolSize</p><blockquote><p>最大线程数量</p></blockquote></li></ul><h3 id="常用方法" tabindex="-1">常用方法 <a class="header-anchor" href="#常用方法" aria-label="Permalink to &quot;常用方法&quot;">​</a></h3><ul><li><p>shutdown</p><blockquote><p>结束线程池，但会执行完已提交的任务。不会接收新任务。</p></blockquote></li><li><p>shutdownNow</p><blockquote><p>结束线程池，不会执行队列中的任务。并对所有工作线程进行中断。</p></blockquote></li><li><p>allowCoreThreadTimeOut</p><blockquote><p>设置是否允许核心线程超时关闭</p></blockquote></li><li><p>getActiveCount</p><blockquote><p>获取工作线程数量</p></blockquote></li><li><p>getLargestPoolSize</p><blockquote><p>获取最大的工作线程数量</p></blockquote></li><li><p>getTaskCount</p><blockquote><p>获取执行的任务数量，包括执行中的。是一个近似值。</p></blockquote></li><li><p>getCompletedTaskCount</p><blockquote><p>获取已完成的任务数量。不包含运行中的。也是一个近似值。</p></blockquote></li><li><p>beforeExecute</p><blockquote><p>每一个任务执行前调用的方法，可以通过子类实现。</p></blockquote></li><li><p>afterExecute</p><blockquote><p>每一个任务执行后调用的方法，可以通过子类实现。</p></blockquote></li><li><p>prestartAllCoreThreads</p><blockquote><p>启动所有核心线程</p></blockquote></li><li><p>prestartCoreThread</p><blockquote><p>启动一个核心线程</p></blockquote></li><li><p>ensurePrestart</p><blockquote><p>和<code>prestartCoreThread</code>一样，不过核心线程数为 0 是也会启动一个线程。</p></blockquote></li><li><p>purge</p><blockquote><p>取消掉所有以结束的任务</p></blockquote></li></ul><h3 id="scheduledthreadpoolexecutor" tabindex="-1">ScheduledThreadPoolExecutor <a class="header-anchor" href="#scheduledthreadpoolexecutor" aria-label="Permalink to &quot;ScheduledThreadPoolExecutor&quot;">​</a></h3><blockquote><p>定时调度的线程池，继承与<code>ThreadPoolExecutor</code>。通过重写<code>submit</code>，<code>execute</code>等方法，并实现私有的<code>BlockingQueue</code>：<code>java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue</code>。把所有的的任务都包装成<code>java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask</code>来进行统一管理。</p></blockquote><h4 id="scheduledfuturetask" tabindex="-1">ScheduledFutureTask <a class="header-anchor" href="#scheduledfuturetask" aria-label="Permalink to &quot;ScheduledFutureTask&quot;">​</a></h4><blockquote><p>封装所有的任务，进行统一的调度。</p></blockquote><h5 id="主要属性" tabindex="-1">主要属性 <a class="header-anchor" href="#主要属性" aria-label="Permalink to &quot;主要属性&quot;">​</a></h5><ul><li>sequenceNumber：在创建任务是生成的序列号，在执行时间一致时来决定执行顺序</li><li>time：执行时间，用来进行排序，决定执行顺序。</li><li>period：周期。大于 0 时为固定速率，等于 0 时为非周期任务，小于 0 是为固定延迟执行。</li><li>heapIndex：在队列<code>DelayedWorkQueue</code>的索引，用来快速取消。</li></ul><h5 id="主要函数" tabindex="-1">主要函数 <a class="header-anchor" href="#主要函数" aria-label="Permalink to &quot;主要函数&quot;">​</a></h5><ul><li>compareTo：执行顺序的关键，通过对比<code>time</code>，<code>sequenceNumber</code>进行比较。</li><li>getDelay：返回剩余的延迟，0 或负数则表示已经过去。</li><li><strong>run</strong>：核心函数，如果是周期任务则在执行完后重新设置下次执行的时间，并把当前任务加入到队列中。</li></ul><h4 id="delayedworkqueue" tabindex="-1">DelayedWorkQueue <a class="header-anchor" href="#delayedworkqueue" aria-label="Permalink to &quot;DelayedWorkQueue&quot;">​</a></h4><blockquote><p>一个私有的无界阻塞队列，针对 ScheduledThreadPool 进行特殊处理。主要表现在获取数据时通过<code>ScheduledFutureTask#getDelay</code>来处理。</p></blockquote><h5 id="主要属性-1" tabindex="-1">主要属性 <a class="header-anchor" href="#主要属性-1" aria-label="Permalink to &quot;主要属性&quot;">​</a></h5><ul><li>leader：下一个任务执行的线程。只有该线程是延时阻塞，其他线程都是无限期等待。在获取完任务后会唤醒一个等待的线程。</li><li>available：一个条件信号，在leader发生变更时会发出条件信号。</li></ul><h5 id="主要函数-1" tabindex="-1">主要函数 <a class="header-anchor" href="#主要函数-1" aria-label="Permalink to &quot;主要函数&quot;">​</a></h5><ul><li>take：获取任务，获取不到无限等待。在当前线程不用回收是，线程池通过该方法获取任务。</li><li>poll：获取任务，获取不到超时等待。在当前线程可以被回收是，通过该方法获取任务。</li><li>offer：添加任务。设置<code>ScheduledFutureTask#heapIndex</code>，<strong>并唤醒一个线程获取任务</strong>。</li></ul><h4 id="主要函数-2" tabindex="-1">主要函数 <a class="header-anchor" href="#主要函数-2" aria-label="Permalink to &quot;主要函数&quot;">​</a></h4><ul><li>decorateTask：可以通过子类来修改运行的任务。</li><li>delayedExecute：延时执行任务。</li><li>schedule：添加任务，把任务都包装成<code>RunnableScheduledFuture</code>放入到延时队列中。</li></ul>',20),h=[d,r,i,p];function s(b,k,n,q,m,_){return a(),l("div",null,h)}const x=o(u,[["render",s]]);export{f as __pageData,x as default};
