import{_ as o,c,o as t,b as e,d as r,a as s}from"./app.55d73d08.js";const g=JSON.parse('{"title":"spring-cloud-context 详细源码","description":"","frontmatter":{"title":"spring-cloud-context 详细源码"},"headers":[{"level":3,"title":"RefreshScope 实现","slug":"refreshscope-实现","link":"#refreshscope-实现","children":[]}],"relativePath":"java/spring-cloud/context.md","lastUpdated":1677490656000}'),d={name:"java/spring-cloud/context.md"},a=e("h3",{id:"refreshscope-实现",tabindex:"-1"},[r("RefreshScope 实现 "),e("a",{class:"header-anchor",href:"#refreshscope-实现","aria-hidden":"true"},"#")],-1),n=e("p",null,"流程图",-1),i=e("iframe",{id:"embed_dom",name:"embed_dom",frameborder:"0",style:{display:"block",width:"525px",height:"245px"},src:"https://www.processon.com/embed/6348db5b7d9c080c425579d1"},null,-1),l=s("<p>注意事项</p><ul><li>不要太对类都加上<code>@RefreshScope</code>，在刷新时，以及访问时是用的同一把锁。</li><li>有<code>@RefreshScope</code>时，spring Aop 回不生效的。 <ul><li>所有对象都会用<code>LockedScopedProxyFactoryBean</code>对象包装着</li><li>继承与<code>ScopedProxyFactoryBean</code>，这个对象回把代理的对象添加上<code>AopInfrastructureBean</code></li><li>有<code>AopInfrastructureBean</code> 接口就不会被代理</li></ul></li></ul>",2),p=[a,n,i,l];function _(h,u,f,m,x,S){return t(),c("div",null,p)}const B=o(d,[["render",_]]);export{g as __pageData,B as default};
