import{_ as e,c as t,a3 as i,o as a}from"./chunks/framework.BChxy9sN.js";const f=JSON.parse('{"title":"synchronized","description":"","frontmatter":{"title":"synchronized"},"headers":[],"relativePath":"java/JVM/synchronized.md","filePath":"java/JVM/synchronized.md"}'),l={name:"java/JVM/synchronized.md"};function n(r,o,p,s,c,d){return a(),t("div",null,o[0]||(o[0]=[i('<p><strong>偏向锁</strong></p><blockquote><p>为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p></blockquote><ul><li><p>JDK 1.6 开始默认开启偏向锁</p></li><li><p>在jdk15中偏向锁默认关闭</p></li><li><p>开启偏向锁：<code>-XX:+UseBiasedLocking</code></p></li><li><p>关闭偏向锁：<code>-XX:-UseBiasedLocking</code></p></li><li><p>偏向锁生效时间：<code>-XX:BiasedLockingStartupDelay=5</code></p></li></ul><p><strong>轻量级锁</strong></p><blockquote><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p></blockquote><p><strong>锁消除</strong></p><blockquote><p>消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。<strong>锁消除的依据是逃逸分析的数据支持。</strong></p></blockquote><ul><li>锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），<strong>同时必须开启逃逸分析</strong></li><li>开启锁消除：-XX:+EliminateLocks</li></ul><p><strong>逃逸分析</strong></p><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ul><li><p>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p></li><li><p>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p></li><li><p>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p></li><li><p>开启逃逸分析， <code>-XX:+DoEscapeAnalysis</code></p></li><li><p>从jdk 1.7开始已经默认开启逃逸分析，如需关闭，需要指定<code>-XX:-DoEscapeAnalysis</code></p></li></ul><h3 id="wait-notify" tabindex="-1">wait notify <a class="header-anchor" href="#wait-notify" aria-label="Permalink to &quot;wait notify&quot;">​</a></h3><blockquote><p>只能在获得同步锁后使用</p><p>调用wait后进入 waitSet 队列吗，等待 notify</p></blockquote><ul><li>有些情况 WaitSet 的对象会被移动到 EntryList</li></ul>',14)]))}const g=e(l,[["render",n]]);export{f as __pageData,g as default};
