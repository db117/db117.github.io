import{_ as c,c as t,j as e,a as r,a3 as a,o as d}from"./chunks/framework.lVUbth6I.js";const h=JSON.parse('{"title":"spring-cloud-context 详细源码","description":"","frontmatter":{"title":"spring-cloud-context 详细源码"},"headers":[],"relativePath":"java/spring-cloud/context.md","filePath":"java/spring-cloud/context.md"}'),s={name:"java/spring-cloud/context.md"};function n(l,o,i,p,u,f){return d(),t("div",null,o[0]||(o[0]=[e("h3",{id:"refreshscope-实现",tabindex:"-1"},[r("RefreshScope 实现 "),e("a",{class:"header-anchor",href:"#refreshscope-实现","aria-label":'Permalink to "RefreshScope 实现"'},"​")],-1),e("p",null,"流程图",-1),e("iframe",{id:"embed_dom",name:"embed_dom",frameborder:"0",style:{display:"block",width:"525px",height:"245px"},src:"https://www.processon.com/embed/6348db5b7d9c080c425579d1"},null,-1),a("<p>注意事项</p><ul><li>不要太对类都加上<code>@RefreshScope</code>，在刷新时，以及访问时是用的同一把锁。</li><li>有<code>@RefreshScope</code>时，spring Aop 回不生效的。 <ul><li>所有对象都会用<code>LockedScopedProxyFactoryBean</code>对象包装着</li><li>继承与<code>ScopedProxyFactoryBean</code>，这个对象回把代理的对象添加上<code>AopInfrastructureBean</code></li><li>有<code>AopInfrastructureBean</code> 接口就不会被代理</li></ul></li></ul>",2)]))}const x=c(s,[["render",n]]);export{h as __pageData,x as default};
