import{_ as a,c as l,a3 as i,o as c}from"./chunks/framework.SFEPx7-A.js";const f=JSON.parse('{"title":"JDK 中的 buffer 体系","description":"","frontmatter":{"title":"JDK 中的 buffer 体系"},"headers":[],"relativePath":"java/JDK/Buffer.md","filePath":"java/JDK/Buffer.md"}'),n={name:"java/JDK/Buffer.md"};function t(o,e,s,p,r,d){return c(),l("div",null,e[0]||(e[0]=[i(`<h2 id="nio-对-buffer-的顶层抽象" tabindex="-1">NIO 对 Buffer 的顶层抽象 <a class="header-anchor" href="#nio-对-buffer-的顶层抽象" aria-label="Permalink to &quot;NIO 对 Buffer 的顶层抽象&quot;">​</a></h2><blockquote><p>本质上是一块内存，可以简单的理解为一个数组。</p><p>Java 中一共有八种基本类型，JDK NIO 也为这八种基本类型分别提供了其对应的 Buffer 类（除了Boolean）。</p></blockquote><h4 id="关键属性" tabindex="-1">关键属性 <a class="header-anchor" href="#关键属性" aria-label="Permalink to &quot;关键属性&quot;">​</a></h4><ul><li>capacity <ul><li>容量</li></ul></li><li>position <ul><li>下一个可以操作的位置，写模式下是下一个写入的位置。读模式下是下一个读的位置</li></ul></li><li>limit <ul><li>可操作的上限</li></ul></li><li>mark <ul><li>标记一个<code>position</code>，可以使用<code>reset</code>还原</li></ul></li></ul><h4 id="数据储存方式" tabindex="-1">数据储存方式 <a class="header-anchor" href="#数据储存方式" aria-label="Permalink to &quot;数据储存方式&quot;">​</a></h4><ul><li>HeapBuffer <ul><li>在堆中有个数组</li></ul></li><li>DirectBuffer <ul><li>在堆外内存中分配</li></ul></li><li>MappedBuffer <ul><li>通过内存文件映射将文件中的内容直接映射到堆外内存中，其本质也是一个 <code>DirectBuffer</code></li></ul></li></ul><h4 id="主要方法" tabindex="-1">主要方法 <a class="header-anchor" href="#主要方法" aria-label="Permalink to &quot;主要方法&quot;">​</a></h4><ul><li>flip <ul><li>切换到读模式</li><li><code>limit</code> 的上限为下一个要写入的位置</li><li><code>position</code>设置为 0 。这样使得我们可以从头开始读取 <code>Buffer</code> 中写入的数据。</li></ul></li><li>clear <ul><li>切换到写模式</li><li>属性回到初始模式</li><li>如果数据未读取，则会覆盖</li></ul></li><li>compact <ul><li>切换到读模式</li><li>与<code>clear</code>的区别主要是保留未读取的数据，<code>HeapByteBuffer</code> 中是把数据移动到最左端</li></ul></li><li>rewind <ul><li>重新读取数据</li><li><code>position</code> 的值重新设置为 0，并丢弃 <code>mark</code></li></ul></li></ul><h2 id="buffer-具体实现" tabindex="-1">Buffer 具体实现 <a class="header-anchor" href="#buffer-具体实现" aria-label="Permalink to &quot;Buffer 具体实现&quot;">​</a></h2><blockquote><p>其他的Buffer实现都是基于 ByteBuffer 的。</p></blockquote><h4 id="主要方法-1" tabindex="-1">主要方法 <a class="header-anchor" href="#主要方法-1" aria-label="Permalink to &quot;主要方法&quot;">​</a></h4><ul><li><p>slice</p><ul><li>创建出来的 <code>ByteBuffer</code> 视图内容是从原生 <code>ByteBufer</code> 的当前位置 <code>position</code> 开始一直到 <code>limit</code> 之间的数据。也就是说创建出来的视图里边的数据是原生 <code>ByteBuffer</code> 中还未处理的数据部分</li></ul></li><li><p>duplicate</p><ul><li>相当于就是完全复刻原生 <code>ByteBuffer</code>。它们的 <code>offset</code>，<code>mark</code>，<code>position</code>，<code>limit</code>，<code>capacity</code> 变量的值全部是一样的，这里需要注意虽然值是一样的，但是它们各自之间是相互独立的。用于对同一字节数组做不同的逻辑处理。</li></ul></li></ul><h4 id="读写相关操作" tabindex="-1">读写相关操作 <a class="header-anchor" href="#读写相关操作" aria-label="Permalink to &quot;读写相关操作&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//从ByteBuffer中读取一个字节的数据，随后position的位置向后移动一位</span></span>
<span class="line"><span> public abstract byte get();</span></span>
<span class="line"><span></span></span>
<span class="line"><span> //向ByteBuffer中写入一个字节的数据，随后position的位置向后移动一位</span></span>
<span class="line"><span> public abstract ByteBuffer put(byte b);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> //按照指定index从ByteBuffer中读取一个字节的数据，position的位置保持不变</span></span>
<span class="line"><span> public abstract byte get(int index);</span></span>
<span class="line"><span></span></span>
<span class="line"><span> //按照指定index向ByteBuffer中写入一个字节的数据，position的位置保持不变</span></span>
<span class="line"><span> public abstract ByteBuffer put(int index, byte b);</span></span></code></pre></div><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to &quot;参考&quot;">​</a></h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247485497&amp;idx=1&amp;sn=eb4afe6764b2b976fb80f6dc5c6fd68a&amp;chksm=ce77ce7ef900476865864e09bb6f0688ca784afc396084ecc90a894bfd733692049c332edd11&amp;token=927203489&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247485497&amp;idx=1&amp;sn=eb4afe6764b2b976fb80f6dc5c6fd68a&amp;chksm=ce77ce7ef900476865864e09bb6f0688ca784afc396084ecc90a894bfd733692049c332edd11&amp;token=927203489&amp;lang=zh_CN&amp;scene=21#wechat_redirect</a></p>`,16)]))}const b=a(n,[["render",t]]);export{f as __pageData,b as default};
