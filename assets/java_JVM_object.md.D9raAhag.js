import{_ as a,c as s,o as e,a5 as o}from"./chunks/framework.gVONBIN7.js";const g=JSON.parse('{"title":"对象相关","description":"","frontmatter":{"title":"对象相关"},"headers":[],"relativePath":"java/JVM/object.md","filePath":"java/JVM/object.md"}'),n={name:"java/JVM/object.md"},t=o(`<h2 id="类加载" tabindex="-1">类加载 <a class="header-anchor" href="#类加载" aria-label="Permalink to &quot;类加载&quot;">​</a></h2><h3 id="加载流程" tabindex="-1">加载流程 <a class="header-anchor" href="#加载流程" aria-label="Permalink to &quot;加载流程&quot;">​</a></h3><ul><li><p>加载</p><blockquote><p>在硬盘上查找并通过IO读入字节码文件，<strong>使用到类时才会加载</strong>，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 <strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></blockquote></li><li><p>验证</p><blockquote><p>校验字节码文件的正确性</p></blockquote></li><li><p>准备</p><blockquote><p>给类的静态变量分配内存，并赋予默认值</p></blockquote></li><li><p>解析</p><blockquote><p>将<strong>符号引用</strong>替换为直接引用，该阶段会把一些静态方法(符号引用，比如 main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的<strong>静态链接</strong>过 程(类加载期间完成)，<strong>动态链接</strong>是在程序运行期间完成的将符号引用替换为直接引用</p></blockquote></li><li><p>初始化</p><blockquote><p>对类的静态变量初始化为指定的值，执行静态代码块</p></blockquote></li></ul><blockquote><p>类被加载到方法区中后主要包含 <strong>运行时常量池、类型信息、字段信息、方法信息、类加载器的</strong></p><p><strong>引用、对应class实例的引用</strong>等信息。</p><p><strong>类加载器的引用</strong>：这个类到类加载器实例的引用</p><p><strong>对应class实例的引用</strong>：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的</p><p>对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。</p></blockquote><h3 id="双亲委派机制" tabindex="-1">双亲委派机制 <a class="header-anchor" href="#双亲委派机制" aria-label="Permalink to &quot;双亲委派机制&quot;">​</a></h3><ul><li><p>引导类加载器</p><blockquote><p>负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等</p></blockquote></li><li><p>扩展类加载器</p><blockquote><p>负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR 包</p></blockquote></li><li><p>应用程序类加载器</p><blockquote><p>负责加载ClassPath路径下的类包，主要就是加载项目写的那些类</p></blockquote></li><li><p>自定义加载器</p><blockquote><p>负责加载用户自定义路径下的类包</p></blockquote></li></ul><blockquote><p><strong>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</strong></p></blockquote><blockquote><p>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心 API库被随意篡改</p><p>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一 次，保证<strong>被加载类的唯一性</strong></p></blockquote><h2 id="对象创建流程" tabindex="-1">对象创建流程 <a class="header-anchor" href="#对象创建流程" aria-label="Permalink to &quot;对象创建流程&quot;">​</a></h2><h3 id="类加载检查" tabindex="-1">类加载检查 <a class="header-anchor" href="#类加载检查" aria-label="Permalink to &quot;类加载检查&quot;">​</a></h3><blockquote><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个</p><p>符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p></blockquote><h3 id="分配内存" tabindex="-1">分配内存 <a class="header-anchor" href="#分配内存" aria-label="Permalink to &quot;分配内存&quot;">​</a></h3><blockquote><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类 加载完成后便可完全确定，为</p><p>对象分配空间的任务等同于把 一块确定大小的内存从Java堆中划分出来。</p></blockquote><p><strong>划分内存的方法：</strong></p><ul><li>“指针碰撞”（Bump the Pointer）(默认用指针碰撞)</li></ul><p>如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><ul><li>“空闲列表”（Free List）</li></ul><p>如果Java堆中的内存并不是规整的，已使用的内存和空 闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记 录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例， 并更新列表上的记录</p><p><strong>解决并发问题的方法：</strong></p><ul><li>CAS（compare and swap）</li></ul><p>虚拟机采用<strong>CAS配上失败重试</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p><ul><li>本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）</li></ul><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过**-XX:+/-UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启**)，-XX:TLABSize 指定TLAB大小。</p><h3 id="初始化零值" tabindex="-1">初始化零值 <a class="header-anchor" href="#初始化零值" aria-label="Permalink to &quot;初始化零值&quot;">​</a></h3><blockquote><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p></blockquote><h3 id="设置对象头" tabindex="-1">设置对象头 <a class="header-anchor" href="#设置对象头" aria-label="Permalink to &quot;设置对象头&quot;">​</a></h3><blockquote><p>初始化零值之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头Object Header之中。</p><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时 间戳等。对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>对象头在hotspot的C++源码markOop.hpp文件里的注释：</span></span>
<span class="line"><span>// Bit-format of an object header (most significant first, big endian layout below):</span></span>
<span class="line"><span>//</span></span>
<span class="line"><span>//  32 bits:</span></span>
<span class="line"><span>//  --------</span></span>
<span class="line"><span>//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span>
<span class="line"><span>//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span>
<span class="line"><span>//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span>
<span class="line"><span>//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span>
<span class="line"><span>//</span></span>
<span class="line"><span>//  64 bits:</span></span>
<span class="line"><span>//  --------</span></span>
<span class="line"><span>//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normalbrew object)</span></span>
<span class="line"><span>//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span>
<span class="line"><span>//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span>
<span class="line"><span>//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span>
<span class="line"><span>//</span></span>
<span class="line"><span>//  unused:25 hash:31 --&gt;| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)</span></span>
<span class="line"><span>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)</span></span>
<span class="line"><span>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)</span></span>
<span class="line"><span>//  unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block)</span></span></code></pre></div><h3 id="执行init方法" tabindex="-1">执行<strong>init</strong>方法 <a class="header-anchor" href="#执行init方法" aria-label="Permalink to &quot;执行**init**方法&quot;">​</a></h3><blockquote><p>执行<strong>init</strong>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。</p></blockquote><h2 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h2><h3 id="指针压缩" tabindex="-1">指针压缩 <a class="header-anchor" href="#指针压缩" aria-label="Permalink to &quot;指针压缩&quot;">​</a></h3><blockquote><p>jvm配置参数:UseCompressedOops，compressed--压缩、oop(ordinary object pointer)--对象指针</p><p>启用指针压缩:-XX:+UseCompressedOops(<strong>默认开启</strong>)，禁止指针压缩:-XX:-UseCompressedOops</p></blockquote><h4 id="为什么要进行指针压缩" tabindex="-1">为什么要进行指针压缩？ <a class="header-anchor" href="#为什么要进行指针压缩" aria-label="Permalink to &quot;为什么要进行指针压缩？&quot;">​</a></h4><ol><li><p>在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，<strong>占用较大宽带，同时GC也会承受较大压力</strong></p></li><li><p>为了减少64位平台下内存的消耗，启用指针压缩功能</p></li><li><p>在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入<strong>堆内存</strong>时压缩编码、取出到<strong>cpu寄存器</strong>后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)</p></li><li><p>堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间</p></li><li><p>堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p></li></ol>`,35),p=[t];function l(i,r,c,b,u,d){return e(),s("div",null,p)}const k=a(n,[["render",l]]);export{g as __pageData,k as default};
