import{_ as n,c as a,o as p,ah as l}from"./chunks/framework.1mMYEF3_.js";const h=JSON.parse('{"title":"Reactor","description":"","frontmatter":{"title":"Reactor"},"headers":[],"relativePath":"java/util/reactor.md","filePath":"java/util/reactor.md"}'),e={name:"java/util/reactor.md"};function i(t,s,c,o,r,u){return p(),a("div",null,[...s[0]||(s[0]=[l(`<blockquote><p><a href="https://projectreactor.io/" target="_blank" rel="noreferrer">https://projectreactor.io/</a></p><p><a href="https://github.com/reactor" target="_blank" rel="noreferrer">https://github.com/reactor</a></p></blockquote><h3 id="创建序列" tabindex="-1">创建序列 <a class="header-anchor" href="#创建序列" aria-label="Permalink to &quot;创建序列&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 生成固定的序列</span></span>
<span class="line"><span>Flux.just(1, 2, 3);</span></span>
<span class="line"><span>Flux.range(1, 12);</span></span>
<span class="line"><span>Flux.from();</span></span>
<span class="line"><span>Flux.fromArray();</span></span>
<span class="line"><span>Flux.fromStream();</span></span>
<span class="line"><span>Flux.fromIterable();</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 从 1 生成到 10</span></span>
<span class="line"><span>Flux.&lt;Integer, Integer&gt;generate(() -&gt; 1, (s, o) -&gt; {</span></span>
<span class="line"><span>			if (s &lt; 11) {</span></span>
<span class="line"><span>				o.next(s);</span></span>
<span class="line"><span>			}</span></span>
<span class="line"><span>			else {</span></span>
<span class="line"><span>				o.complete();</span></span>
<span class="line"><span>			}</span></span>
<span class="line"><span>			return s + 1;</span></span>
<span class="line"><span>		});</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span># 按照时间间隔生成</span></span>
<span class="line"><span>Flux.interval(Duration.ofMillis(100), Duration.ofMillis(100), Schedulers.newSingle(&quot;interval-test&quot;))</span></span>
<span class="line"><span>      .take(5, false)</span></span>
<span class="line"><span>      .map(v -&gt; System.currentTimeMillis())</span></span>
<span class="line"><span>      .subscribe(ts);</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 通过回到方法生成</span></span>
<span class="line"><span>Flux.create(sink -&gt; {</span></span>
<span class="line"><span>			    sink.next(&quot;1&quot;);</span></span>
<span class="line"><span>			    sink.next(&quot;2&quot;);</span></span>
<span class="line"><span>			    sink.complete();</span></span>
<span class="line"><span>		    });</span></span></code></pre></div><h3 id="改变序列" tabindex="-1">改变序列 <a class="header-anchor" href="#改变序列" aria-label="Permalink to &quot;改变序列&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 1 变 1</span></span>
<span class="line"><span># 直接转换对象</span></span>
<span class="line"><span>Flux.map();</span></span>
<span class="line"><span># 强转转换对象，如果不能转就报错</span></span>
<span class="line"><span>Flux.cast();</span></span>
<span class="line"><span># 给每一个数据添加一个索引</span></span>
<span class="line"><span>Flux.index();</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 1 变 多</span></span>
<span class="line"><span># 把一个元素变成另一个元素序列</span></span>
<span class="line"><span>Flux.flatMap(); </span></span>
<span class="line"><span># 把一个元素变成另一个元素序列（按照顺序来）</span></span>
<span class="line"><span>Flux.flatMapSequential(); </span></span>
<span class="line"><span># 直接消费元素以及一个SynchronousSink。可以做各种操作</span></span>
<span class="line"><span>Flux.handle();</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span># 拼接序列</span></span>
<span class="line"><span># 把一个序列加到当前序列前面</span></span>
<span class="line"><span>Flux.startWith();</span></span>
<span class="line"><span># 把一个序列加到当前序列后面</span></span>
<span class="line"><span>Flux.concatWithValues();</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 聚合序列</span></span>
<span class="line"><span># 聚合成一个 list</span></span>
<span class="line"><span>collectList();</span></span>
<span class="line"><span>collectSortedList();</span></span>
<span class="line"><span># 分组聚合</span></span>
<span class="line"><span>collectMap();</span></span>
<span class="line"><span>collectMultiMap();</span></span>
<span class="line"><span># 给一个初始数据，一个转换方法聚合成一个对象</span></span>
<span class="line"><span>reduce();</span></span>
<span class="line"><span># 聚合成一个 Boolean</span></span>
<span class="line"><span>all();# 全部元素都满足</span></span>
<span class="line"><span>any();# 任意一个元素满足</span></span>
<span class="line"><span>hasElement();# 包含指定元素</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 合并序列</span></span>
<span class="line"><span># 简单合并两个序列，不阻塞排序</span></span>
<span class="line"><span>merge();</span></span>
<span class="line"><span># 按照顺序合并序列</span></span>
<span class="line"><span>mergeSequential();</span></span>
<span class="line"><span># 组和序列，对不同序列的元素进行配对</span></span>
<span class="line"><span>zip();</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 把一个元素转换成一个序列</span></span>
<span class="line"><span>expand();</span></span></code></pre></div><h3 id="查看序列" tabindex="-1">查看序列 <a class="header-anchor" href="#查看序列" aria-label="Permalink to &quot;查看序列&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 每一个元素都查看</span></span>
<span class="line"><span>doOnNext();</span></span>
<span class="line"><span># 完成后调用</span></span>
<span class="line"><span>doOnComplete();</span></span>
<span class="line"><span># 出现异常后调用</span></span>
<span class="line"><span>doOnError();</span></span>
<span class="line"><span># 取消后调用</span></span>
<span class="line"><span>doOnCancel();</span></span>
<span class="line"><span># 第一个元素触发</span></span>
<span class="line"><span>doFirst();</span></span>
<span class="line"><span>doOnSubscribe();</span></span>
<span class="line"><span># request 时触发</span></span>
<span class="line"><span>doOnRequest();</span></span>
<span class="line"><span># 结束后触发，正常和异常都会调用但是取消不会。</span></span>
<span class="line"><span>doOnTerminate();</span></span>
<span class="line"><span># 消费一个 single 对象。可以根据元素状态进行处理</span></span>
<span class="line"><span>doOnEach();</span></span>
<span class="line"><span># 结束都会调用</span></span>
<span class="line"><span>doFinally();</span></span></code></pre></div><h3 id="过滤元素" tabindex="-1">过滤元素 <a class="header-anchor" href="#过滤元素" aria-label="Permalink to &quot;过滤元素&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 同步过滤元素</span></span>
<span class="line"><span>filter();</span></span>
<span class="line"><span># 异步过滤元素</span></span>
<span class="line"><span>filterWhen();</span></span>
<span class="line"><span># 过滤指定类型的元素</span></span>
<span class="line"><span>ofType();</span></span>
<span class="line"><span># 忽略元素</span></span>
<span class="line"><span>ignoreElements();</span></span>
<span class="line"><span># 去重元素</span></span>
<span class="line"><span>distinct();</span></span>
<span class="line"><span># 去掉连续相同的元素</span></span>
<span class="line"><span>distinctUntilChanged();</span></span>
<span class="line"><span># 获取一定数量或时间的元素</span></span>
<span class="line"><span>take();</span></span>
<span class="line"><span># 获取最后一个元素</span></span>
<span class="line"><span>takeLast();</span></span>
<span class="line"><span># 获取直到返回 true。（换返回第一个为 true 的元素）</span></span>
<span class="line"><span>takeUntil();</span></span>
<span class="line"><span># 获取直到返回 false（不返回第一个为 false 的元素）</span></span>
<span class="line"><span>takeWhile();</span></span>
<span class="line"><span># 获取第多少元素</span></span>
<span class="line"><span>elementAt();</span></span>
<span class="line"><span># 跳过多少个或多长时间</span></span>
<span class="line"><span>skip();</span></span>
<span class="line"><span># 跳过直到返回 true 为止（最后一个返回 false 的不会包含在内）</span></span>
<span class="line"><span>skipUntil();</span></span>
<span class="line"><span># 跳过直到返回 false 为止（最后一个返回 true 的不会包含在内）</span></span>
<span class="line"><span>skipWhile();</span></span>
<span class="line"><span># 周期内的最后一个元素</span></span>
<span class="line"><span>sample();</span></span></code></pre></div><h3 id="处理异常" tabindex="-1">处理异常 <a class="header-anchor" href="#处理异常" aria-label="Permalink to &quot;处理异常&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 触发异常</span></span>
<span class="line"><span># 直接发出一个异常</span></span>
<span class="line"><span>error();</span></span>
<span class="line"><span># 拼接一个异常</span></span>
<span class="line"><span>.concat(Flux.error(e))();</span></span>
<span class="line"><span>.then(Mono.error(e))();</span></span>
<span class="line"><span># 超时异常</span></span>
<span class="line"><span>timeout();</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 异常后处理</span></span>
<span class="line"><span># 异常后返回指定数据</span></span>
<span class="line"><span>onErrorReturn();</span></span>
<span class="line"><span># 异常后转为完成，相当于 catch</span></span>
<span class="line"><span>onErrorComplete();</span></span>
<span class="line"><span># 异常后转为另一个流</span></span>
<span class="line"><span>onErrorResume();</span></span>
<span class="line"><span># 转本异常类型</span></span>
<span class="line"><span>onErrorMap();</span></span>
<span class="line"><span># 重试</span></span>
<span class="line"><span>retry();</span></span>
<span class="line"><span>retryWhen();</span></span></code></pre></div><h3 id="拆分流" tabindex="-1">拆分流 <a class="header-anchor" href="#拆分流" aria-label="Permalink to &quot;拆分流&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 按照窗口大小，或时间进行拆分</span></span>
<span class="line"><span>window();</span></span>
<span class="line"><span># 满足条件就分组 </span></span>
<span class="line"><span>windowUntil():</span></span>
<span class="line"><span># 按照数量分组，如果超时也分组</span></span>
<span class="line"><span>windowTimeout():</span></span>
<span class="line"><span># 满足条件就分租</span></span>
<span class="line"><span>windowWhile ():</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 按照数量或时间分成集合</span></span>
<span class="line"><span>buffer():</span></span>
<span class="line"><span># 按照数量分成集合，如果超时也分成集合</span></span>
<span class="line"><span>bufferTimeout():</span></span>
<span class="line"><span># 按照条件分集合</span></span>
<span class="line"><span>bufferUntil():</span></span>
<span class="line"><span>bufferWhile():</span></span></code></pre></div>`,13)])])}const b=n(e,[["render",i]]);export{h as __pageData,b as default};
