(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{310:function(t,e,n){"use strict";n.r(e);var r=n(10),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("加锁目的："),e("strong",[t._v("序列化访问临界资源")]),t._v("，即同一时刻只能有一个线程访问临界资源("),e("strong",[t._v("同步互斥访问")]),t._v(")")]),t._v(" "),e("p",[e("code",[t._v("synchronized")]),t._v("内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问，是可重入的。")])]),t._v(" "),e("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/60efe9987d9c0806dcf13836"}}),t._v(" "),e("h3",{attrs:{id:"使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),e("p",[t._v("加锁的方式")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("同步实例方法，锁是当前实例对象")])]),t._v(" "),e("li",[e("p",[t._v("同步类方法，锁是当前类对象")])]),t._v(" "),e("li",[e("p",[t._v("同步代码块，锁是括号里面的对象")])])]),t._v(" "),e("h3",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("synchronized是基于JVM")]),t._v("内置锁实现，通过内部对象"),e("strong",[t._v("Monitor")]),t._v("(监视器锁)实现，基于进入与退出"),e("strong",[t._v("Monitor")]),t._v("对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的"),e("strong",[t._v("Mutex lock")]),t._v("（互斥锁）实现，它是一个重量级锁性能较低。当然，**JVM内置锁在1.5之后版本做了重大的优化，**如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销，，内置锁的并发性能已经基本与Lock持平。")]),t._v(" "),e("p",[t._v("synchronized关键字被编译成字节码后会被翻译成monitorenter 和 monitorexit 两条指令分别在同步块逻辑代码的起始位置与结束位置。")])]),t._v(" "),e("h4",{attrs:{id:"monitor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monitor"}},[t._v("#")]),t._v(" Monitor")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("任何一个对象都有一个Monitor与之关联，当且一个Monitor被持有后，它将处于锁定状态")]),t._v("。Synchronized在JVM里的实现都是 "),e("strong",[t._v("基于进入和退出Monitor对象来实现方法同步和代码块同步")]),t._v("，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。")])]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("monitorenter")]),t._v("：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：")])]),t._v(" "),e("li",[e("ol",[e("li",[e("strong",[t._v("如果monitor的进入数为0")]),t._v("，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；")]),t._v(" "),e("li",[e("strong",[t._v("如果线程已经占有该monitor")]),t._v("，只是重新进入，则进入monitor的进入数加1；")]),t._v(" "),e("li",[e("strong",[t._v("如果其他线程已经占用了monitor")]),t._v("，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；")])])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("monitorexit")]),t._v("：执行monitorexit的线程必须是objectref所对应的monitor的所有者。"),e("strong",[t._v("指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者")]),t._v("。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。")])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("ACC_SYNCHRONIZED")]),t._v("：方法的同步并没有通过指令 "),e("strong",[t._v("monitorenter")]),t._v(" 和 "),e("strong",[t._v("monitorexit")]),t._v(" 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 "),e("strong",[t._v("ACC_SYNCHRONIZED")]),t._v(" 标示符。"),e("strong",[t._v("JVM就是根据该标示符来实现方法的同步的")]),t._v("：")]),t._v(" "),e("p",[t._v("当方法调用时，"),e("strong",[t._v("调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置")]),t._v("，如果设置了，"),e("strong",[t._v("执行线程将先获取monitor")]),t._v("，获取成功之后才能执行方法体，"),e("strong",[t._v("方法执行完后再释放monitor")]),t._v("。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。")])])]),t._v(" "),e("h3",{attrs:{id:"objectmonitor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#objectmonitor"}},[t._v("#")]),t._v(" ObjectMonitor")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁")]),t._v("。")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/e92e2fd4e0bc805d8f7d70f632cce0282eb1809b/src/hotspot/share/runtime/objectMonitor.hpp",target:"_blank",rel:"noopener noreferrer"}},[t._v("源码"),e("OutboundLink")],1)])]),t._v(" "),e("p",[e("code",[t._v("ObjectWaiter")]),t._v("结构")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 对所有需要进入的线程进行封装\nclass ObjectWaiter : public StackObj {\n public:\n  enum TStates { TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ };// 线程状态\n  ObjectWaiter* volatile _next;\t\t// 下一个等待对象\n  ObjectWaiter* volatile _prev;   // 上一个等待对象\n  JavaThread*   _thread;\t\t\t\t\t// 线程\n  uint64_t      _notifier_tid;\n  ParkEvent *   _event;\n  volatile int  _notified;\n  volatile TStates TState;\t\t\t\t\t// 线程状态\n  bool          _active;           // Contention monitoring is enabled\n public:\n  ObjectWaiter(JavaThread* current);\n\n  void wait_reenter_begin(ObjectMonitor *mon);\n  void wait_reenter_end(ObjectMonitor *mon);\n};\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br")])]),e("p",[e("code",[t._v("ObjectMonitor")]),t._v("主要结构")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class ObjectMonitor : public CHeapObj<mtInternal> {\n  friend class ObjectSynchronizer;\n  friend class ObjectWaiter;\n  friend class VMStructs;\n  JVMCI_ONLY(friend class JVMCIVMStructs;)\n\n\n  volatile markWord _header;    \t\t// 对象头\n  WeakHandle _object;               // 锁不是平白出现的，而是寄托存储于对象中。\n  void* volatile _owner;            // 指向所属线程或栈锁的指针\n  volatile uint64_t _previous_owner_tid;  // 上一个拥有当前锁的线程id\n  ObjectMonitor* _next_om;          \t// Next ObjectMonitor* linkage\n  volatile intx _recursions;        \t// 递归次数\n  ObjectWaiter* volatile _EntryList;  // 处于等待锁block状态的线程，会被加入到entry set；\n\n  ObjectWaiter* volatile _cxq;      // LL of recently-arrived threads blocked on entry.\n  JavaThread* volatile _succ;       // Heir presumptive thread - used for futile wakeup throttling\n  int _contentions;                 // 竞争数量\n\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br"),e("span",{staticClass:"line-number"},[t._v("14")]),e("br"),e("span",{staticClass:"line-number"},[t._v("15")]),e("br"),e("span",{staticClass:"line-number"},[t._v("16")]),e("br"),e("span",{staticClass:"line-number"},[t._v("17")]),e("br"),e("span",{staticClass:"line-number"},[t._v("18")]),e("br"),e("span",{staticClass:"line-number"},[t._v("19")]),e("br")])]),e("h3",{attrs:{id:"对象头"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象头"}},[t._v("#")]),t._v(" 对象头")]),t._v(" "),e("blockquote",[e("p",[t._v("所有对象都有的。主要包含锁状态，以及hash值，gc信息")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/openjdk/jdk/blob/e92e2fd4e0bc805d8f7d70f632cce0282eb1809b/src/hotspot/share/oops/markWord.hpp",target:"_blank",rel:"noopener noreferrer"}},[t._v("源码"),e("OutboundLink")],1)])]),t._v(" "),e("p",[e("strong",[t._v("32位")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("25bit")]),t._v(" "),e("th",[t._v("4bit")]),t._v(" "),e("th",[t._v("1bit")]),t._v(" "),e("th",[t._v("2bit")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("锁状态")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("分代年龄")]),t._v(" "),e("td",[t._v("是否偏向锁（是否禁用偏向）")]),t._v(" "),e("td",[t._v("锁标志位")])]),t._v(" "),e("tr",[e("td",[t._v("无锁态")]),t._v(" "),e("td",[t._v("对象的hashCode")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("0")]),t._v(" "),e("td",[t._v("01")])]),t._v(" "),e("tr",[e("td",[t._v("轻量级锁")]),t._v(" "),e("td",[t._v("指向栈中锁记录的指针")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td",[t._v("00")])]),t._v(" "),e("tr",[e("td",[t._v("重量级锁")]),t._v(" "),e("td",[t._v("指向Monitor的指针")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td",[t._v("10")])]),t._v(" "),e("tr",[e("td",[t._v("GC标记")]),t._v(" "),e("td",[t._v("空")]),t._v(" "),e("td"),t._v(" "),e("td"),t._v(" "),e("td",[t._v("11")])]),t._v(" "),e("tr",[e("td",[t._v("偏向锁")]),t._v(" "),e("td",[t._v("线程ID/Epoch(2bit)")]),t._v(" "),e("td"),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("01")])])])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//  jdk源码注释\n//  32 bits:\n//  --------\n//             hash:25 ------------\x3e| age:4  unused_gap:1  lock:2 (normal object)\n//\n//  64 bits:\n//  --------\n//  unused:25 hash:31 --\x3e| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br")])]),e("p",[e("strong",[t._v("对象头分析工具")])]),t._v(" "),e("blockquote",[e("p",[t._v("分析java对象的工具包")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://openjdk.java.net/projects/code-tools/jol/",target:"_blank",rel:"noopener noreferrer"}},[t._v("OpenJDK: jol (java.net)"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/openjdk/jol",target:"_blank",rel:"noopener noreferrer"}},[t._v("github.com"),e("OutboundLink")],1)])]),t._v(" "),e("h3",{attrs:{id:"锁升级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[t._v("#")]),t._v(" 锁升级")]),t._v(" "),e("blockquote",[e("p",[t._v("锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。")])]),t._v(" "),e("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/60efe8155653bb06f24c1df7"}}),t._v(" "),e("p",[e("strong",[t._v("偏向锁")])]),t._v(" "),e("blockquote",[e("p",[t._v("为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("JDK 1.6 开始默认开启偏向锁")])]),t._v(" "),e("li",[e("p",[t._v("在jdk15中偏向锁默认关闭")])]),t._v(" "),e("li",[e("p",[t._v("开启偏向锁："),e("code",[t._v("-XX:+UseBiasedLocking")])])]),t._v(" "),e("li",[e("p",[t._v("关闭偏向锁："),e("code",[t._v("-XX:-UseBiasedLocking")])])]),t._v(" "),e("li",[e("p",[t._v("偏向锁生效时间："),e("code",[t._v("-XX:BiasedLockingStartupDelay=5")])])])]),t._v(" "),e("p",[e("strong",[t._v("轻量级锁")])]),t._v(" "),e("blockquote",[e("p",[t._v("倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。")])]),t._v(" "),e("p",[e("strong",[t._v("锁消除")])]),t._v(" "),e("blockquote",[e("p",[t._v("消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。"),e("strong",[t._v("锁消除的依据是逃逸分析的数据支持。")])])]),t._v(" "),e("ul",[e("li",[t._v("锁消除，前提是java必须运行在server模式（server模式会比client模式作更多的优化），"),e("strong",[t._v("同时必须开启逃逸分析")])]),t._v(" "),e("li",[t._v("开启锁消除：-XX:+EliminateLocks")])]),t._v(" "),e("p",[e("strong",[t._v("逃逸分析")])]),t._v(" "),e("p",[t._v("使用逃逸分析，编译器可以对代码做如下优化：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。")])]),t._v(" "),e("li",[e("p",[t._v("将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。")])]),t._v(" "),e("li",[e("p",[t._v("分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。")])]),t._v(" "),e("li",[e("p",[t._v("开启逃逸分析， "),e("code",[t._v("-XX:+DoEscapeAnalysis")])])]),t._v(" "),e("li",[e("p",[t._v("从jdk 1.7开始已经默认开启逃逸分析，如需关闭，需要指定"),e("code",[t._v("-XX:-DoEscapeAnalysis")])])])]),t._v(" "),e("h3",{attrs:{id:"wait-notify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#wait-notify"}},[t._v("#")]),t._v(" wait notify")]),t._v(" "),e("blockquote",[e("p",[t._v("只能在获得同步锁后使用")]),t._v(" "),e("p",[t._v("调用wait后进入 waitSet 队列吗，等待 notify")])]),t._v(" "),e("ul",[e("li",[t._v("有些情况 WaitSet 的对象会被移动到 EntryList")])]),t._v(" "),e("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/60f555b1637689739c3e5294"}})])}),[],!1,null,null,null);e.default=s.exports}}]);