(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{309:function(t,v,_){"use strict";_.r(v);var a=_(10),e=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"基本参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基本参数"}},[t._v("#")]),t._v(" 基本参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[t._v("参数名称")])]),t._v(" "),v("th",[v("strong",[t._v("含义")])]),t._v(" "),v("th",[v("strong",[t._v("默认值")])]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-Xms")]),t._v(" "),v("td",[t._v("初始堆大小")]),t._v(" "),v("td",[t._v("内存的1/64")]),t._v(" "),v("td",[t._v("默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.")])]),t._v(" "),v("tr",[v("td",[t._v("-Xmx")]),t._v(" "),v("td",[t._v("最大堆大小")]),t._v(" "),v("td",[t._v("内存的1/4")]),t._v(" "),v("td",[t._v("默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制")])]),t._v(" "),v("tr",[v("td",[t._v("-Xmn")]),t._v(" "),v("td",[t._v("年轻代大小")]),t._v(" "),v("td"),t._v(" "),v("td",[v("strong",[t._v("注意")]),t._v("：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:NewSize")]),t._v(" "),v("td",[t._v("设置年轻代大小")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-XX:MaxNewSize")]),t._v(" "),v("td",[t._v("年轻代最大值")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-XX:PermSize")]),t._v(" "),v("td",[t._v("设置持久代(perm gen)初始值")]),t._v(" "),v("td",[t._v("内存的1/64")]),t._v(" "),v("td",[t._v("JDK1.8以前")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:MaxPermSize")]),t._v(" "),v("td",[t._v("设置持久代最大值")]),t._v(" "),v("td",[t._v("内存的1/4")]),t._v(" "),v("td",[t._v("JDK1.8以前")])]),t._v(" "),v("tr",[v("td",[t._v("-Xss")]),t._v(" "),v("td",[t._v("每个线程的堆栈大小")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:NewRatio")]),t._v(" "),v("td",[t._v("年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5 Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:SurvivorRatio")]),t._v(" "),v("td",[t._v("Eden区与Survivor区的大小比值")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:LargePageSizeInBytes")]),t._v(" "),v("td",[t._v("内存页的大小不可设置过大， 会影响Perm的大小")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("=128m")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+UseFastAccessorMethods")]),t._v(" "),v("td",[t._v("原始类型的快速优化")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-XX:+DisableExplicitGC")]),t._v(" "),v("td",[t._v("关闭System.gc()")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("这个参数需要严格的测试")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:MaxTenuringThreshold")]),t._v(" "),v("td",[t._v("垃圾最大年龄")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+UseBiasedLocking")]),t._v(" "),v("td",[t._v("锁机制的性能改善")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-Xnoclassgc")]),t._v(" "),v("td",[t._v("禁用垃圾回收")]),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-XX:PretenureSizeThreshold")]),t._v(" "),v("td",[t._v("对象超过多大是直接在旧生代分配")]),t._v(" "),v("td",[t._v("0")]),t._v(" "),v("td",[t._v("单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:TLABWasteTargetPercent")]),t._v(" "),v("td",[t._v("TLAB占eden区的百分比")]),t._v(" "),v("td",[t._v("1%")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("-XX:+"),v("em",[t._v("CollectGen0First")])]),t._v(" "),v("td",[t._v("FullGC时是否先YGC")]),t._v(" "),v("td",[t._v("false")]),t._v(" "),v("td")])])]),t._v(" "),v("p",[v("strong",[t._v("Jdk8版本的重要特有参数")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[t._v("参数名称")])]),t._v(" "),v("th",[v("strong",[t._v("含义")])]),t._v(" "),v("th",[v("strong",[t._v("默认值")])]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-XX:MetaspaceSize")]),t._v(" "),v("td",[t._v("元空间大小")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("Jdk8版本")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:MaxMetaspaceSize")]),t._v(" "),v("td",[t._v("最大元空间")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("Jdk8版本")])])])]),t._v(" "),v("h3",{attrs:{id:"jvm日志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jvm日志"}},[t._v("#")]),t._v(" JVM日志")]),t._v(" "),v("div",{staticClass:"language-text line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 打印GC的详细信息\n-XX:+PrintGCDetails\n// 打印GC的时间戳\n-XX:+PrintGCDateStamps\n// 在GC前后打印堆信息\n-XX:+PrintHeapAtGC\n// 打印Survivor区中各个年龄段的对象的分布信息\n-XX:+PrintTenuringDistribution\n// JVM启动时输出所有参数值，方便查看参数是否被覆盖\n-XX:+PrintFlagsFinal\n// 打印GC时应用程序的停止时间\n-XX:+PrintGCApplicationStoppedTime\n// 打印在GC期间处理引用对象的时间（仅在PrintGCDetails时启用）\n-XX:+PrintReferenceGC\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br"),v("span",{staticClass:"line-number"},[t._v("14")]),v("br")])]),v("h3",{attrs:{id:"打印参数参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#打印参数参数"}},[t._v("#")]),t._v(" 打印参数参数")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 打印最终使用的jvm参数\n-XX:+PrintFlagsFinal\n\n// 打印默认参数\n-XX:+PrintFlagsInitial \n\n// 打印用户设置的参数\n-XX:+PrintCommandLineFlags\n\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br")])]),v("h3",{attrs:{id:"并行收集器相关参数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并行收集器相关参数"}},[t._v("#")]),t._v(" 并行收集器相关参数")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[v("strong",[t._v("参数名称")])]),t._v(" "),v("th",[v("strong",[t._v("含义")])]),t._v(" "),v("th",[v("strong",[t._v("默认值")])]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("-XX:+UseParallelGC")]),t._v(" "),v("td",[t._v("Full GC采用parallel MSC (此项待验证)")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+UseParNewGC")]),t._v(" "),v("td",[t._v("设置年轻代为并行收集")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("可与CMS收集同时使用 JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:ParallelGCThreads")]),t._v(" "),v("td",[t._v("并行收集器的线程数")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("此值最好配置与处理器数目相等 同样适用于CMS")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+UseParallelOldGC")]),t._v(" "),v("td",[t._v("年老代垃圾收集方式为并行收集(Parallel Compacting)")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("这个是JAVA 6出现的参数选项")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:MaxGCPauseMillis")]),t._v(" "),v("td",[t._v("每次年轻代垃圾回收的最长时间(最大暂停时间)")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+UseAdaptiveSizePolicy")]),t._v(" "),v("td",[t._v("自动选择年轻代区大小和相应的Survivor区比例")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:GCTimeRatio")]),t._v(" "),v("td",[t._v("设置垃圾回收时间占程序运行时间的百分比")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("公式为1/(1+n)")])]),t._v(" "),v("tr",[v("td",[t._v("-XX:+"),v("em",[t._v("ScavengeBeforeFullGC")])]),t._v(" "),v("td",[t._v("Full GC前调用YGC")]),t._v(" "),v("td",[t._v("true")]),t._v(" "),v("td",[t._v("Do young generation GC prior to a full GC. (Introduced in 1.4.1.)")])])])]),t._v(" "),v("h3",{attrs:{id:"其他"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[t._v("#")]),t._v(" 其他")]),t._v(" "),v("h5",{attrs:{id:"xx-perfdisablesharedmem"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xx-perfdisablesharedmem"}},[t._v("#")]),t._v(" -XX:+PerfDisableSharedMem")]),t._v(" "),v("p",[t._v("该参数决定了存储PerfData的内存是不是可以被共享，也就是说不管这个参数设置没设置，jvm在启动的时候都会分配一块内存来存PerfData，只是说这个PerfData是不是其他进程可见的问题，如果设置了这个参数，说明不能被共享，此时其他进程将访问不了该内存，这样一来，譬如我们jps，jstat等都无法工作。默认这个参数是关闭的，也就是默认支持共享的方式")]),t._v(" "),v("h5",{attrs:{id:"xx-useperfdata"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#xx-useperfdata"}},[t._v("#")]),t._v(" -XX:-UsePerfData")]),t._v(" "),v("p",[t._v("如果关闭了UsePerfData这个参数，那么jvm启动过程中perf memory都不会被创建，默认情况是是打开的")]),t._v(" "),v("h4",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);v.default=e.exports}}]);