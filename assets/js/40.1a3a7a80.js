(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{317:function(e,v,_){"use strict";_.r(v);var t=_(10),o=Object(t.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h3",{attrs:{id:"线程池流程图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程池流程图"}},[e._v("#")]),e._v(" 线程池流程图")]),e._v(" "),v("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/619f50e40e3e743d103b520d"}}),e._v(" "),v("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61a48efa1efad425fd73dce4"}}),e._v(" "),v("h3",{attrs:{id:"关键属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关键属性"}},[e._v("#")]),e._v(" 关键属性")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("ctl")]),e._v(" "),v("blockquote",[v("p",[e._v("使用高 2 位保存线程池运行状态，低 29 为保存运行线程数")])])]),e._v(" "),v("li",[v("p",[e._v("workQueue")]),e._v(" "),v("blockquote",[v("p",[e._v("工作队列，保存需要运行的线程")])])]),e._v(" "),v("li",[v("p",[e._v("mainLock")]),e._v(" "),v("blockquote",[v("p",[e._v("主锁，在修改一下核心属性是需要持有该锁")])])]),e._v(" "),v("li",[v("p",[e._v("largestPoolSize")]),e._v(" "),v("blockquote",[v("p",[e._v("达到的最大线程数量，访问需要持有 "),v("code",[e._v("mainLock")])])])]),e._v(" "),v("li",[v("p",[e._v("completedTaskCount")]),e._v(" "),v("blockquote",[v("p",[e._v("完成任务的计数器。访问需要持有 "),v("code",[e._v("mainLock")])])])]),e._v(" "),v("li",[v("p",[e._v("threadFactory")]),e._v(" "),v("blockquote",[v("p",[e._v("线程工厂")])])]),e._v(" "),v("li",[v("p",[e._v("handler")]),e._v(" "),v("blockquote",[v("p",[e._v("添加任务失败，或者强制结束线程是调用")])])]),e._v(" "),v("li",[v("p",[e._v("keepAliveTime")]),e._v(" "),v("blockquote",[v("p",[e._v("工作线程允许空闲时间")])])]),e._v(" "),v("li",[v("p",[e._v("allowCoreThreadTimeOut")]),e._v(" "),v("blockquote",[v("p",[e._v("是否允许核心线程超时，默认 false")])])]),e._v(" "),v("li",[v("p",[e._v("corePoolSize")]),e._v(" "),v("blockquote",[v("p",[e._v("核心线程数量")])])]),e._v(" "),v("li",[v("p",[e._v("maximumPoolSize")]),e._v(" "),v("blockquote",[v("p",[e._v("最大线程数量")])])])]),e._v(" "),v("h3",{attrs:{id:"常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[e._v("#")]),e._v(" 常用方法")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("shutdown")]),e._v(" "),v("blockquote",[v("p",[e._v("结束线程池，但会执行完已提交的任务。不会接收新任务。")])])]),e._v(" "),v("li",[v("p",[e._v("shutdownNow")]),e._v(" "),v("blockquote",[v("p",[e._v("结束线程池，不会执行队列中的任务。并对所有工作线程进行中断。")])])]),e._v(" "),v("li",[v("p",[e._v("allowCoreThreadTimeOut")]),e._v(" "),v("blockquote",[v("p",[e._v("设置是否允许核心线程超时关闭")])])]),e._v(" "),v("li",[v("p",[e._v("getActiveCount")]),e._v(" "),v("blockquote",[v("p",[e._v("获取工作线程数量")])])]),e._v(" "),v("li",[v("p",[e._v("getLargestPoolSize")]),e._v(" "),v("blockquote",[v("p",[e._v("获取最大的工作线程数量")])])]),e._v(" "),v("li",[v("p",[e._v("getTaskCount")]),e._v(" "),v("blockquote",[v("p",[e._v("获取执行的任务数量，包括执行中的。是一个近似值。")])])]),e._v(" "),v("li",[v("p",[e._v("getCompletedTaskCount")]),e._v(" "),v("blockquote",[v("p",[e._v("获取已完成的任务数量。不包含运行中的。也是一个近似值。")])])]),e._v(" "),v("li",[v("p",[e._v("beforeExecute")]),e._v(" "),v("blockquote",[v("p",[e._v("每一个任务执行前调用的方法，可以通过子类实现。")])])]),e._v(" "),v("li",[v("p",[e._v("afterExecute")]),e._v(" "),v("blockquote",[v("p",[e._v("每一个任务执行后调用的方法，可以通过子类实现。")])])]),e._v(" "),v("li",[v("p",[e._v("prestartAllCoreThreads")]),e._v(" "),v("blockquote",[v("p",[e._v("启动所有核心线程")])])]),e._v(" "),v("li",[v("p",[e._v("prestartCoreThread")]),e._v(" "),v("blockquote",[v("p",[e._v("启动一个核心线程")])])]),e._v(" "),v("li",[v("p",[e._v("ensurePrestart")]),e._v(" "),v("blockquote",[v("p",[e._v("和"),v("code",[e._v("prestartCoreThread")]),e._v("一样，不过核心线程数为 0 是也会启动一个线程。")])])]),e._v(" "),v("li",[v("p",[e._v("purge")]),e._v(" "),v("blockquote",[v("p",[e._v("取消掉所有以结束的任务")])])])]),e._v(" "),v("h3",{attrs:{id:"scheduledthreadpoolexecutor"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scheduledthreadpoolexecutor"}},[e._v("#")]),e._v(" ScheduledThreadPoolExecutor")]),e._v(" "),v("blockquote",[v("p",[e._v("定时调度的线程池，继承与"),v("code",[e._v("ThreadPoolExecutor")]),e._v("。通过重写"),v("code",[e._v("submit")]),e._v("，"),v("code",[e._v("execute")]),e._v("等方法，并实现私有的"),v("code",[e._v("BlockingQueue")]),e._v("："),v("code",[e._v("java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue")]),e._v("。把所有的的任务都包装成"),v("code",[e._v("java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask")]),e._v("来进行统一管理。")])]),e._v(" "),v("h4",{attrs:{id:"scheduledfuturetask"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scheduledfuturetask"}},[e._v("#")]),e._v(" ScheduledFutureTask")]),e._v(" "),v("blockquote",[v("p",[e._v("封装所有的任务，进行统一的调度。")])]),e._v(" "),v("h5",{attrs:{id:"主要属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要属性"}},[e._v("#")]),e._v(" 主要属性")]),e._v(" "),v("ul",[v("li",[e._v("sequenceNumber：在创建任务是生成的序列号，在执行时间一致时来决定执行顺序")]),e._v(" "),v("li",[e._v("time：执行时间，用来进行排序，决定执行顺序。")]),e._v(" "),v("li",[e._v("period：周期。大于 0 时为固定速率，等于 0 时为非周期任务，小于 0 是为固定延迟执行。")]),e._v(" "),v("li",[e._v("heapIndex：在队列"),v("code",[e._v("DelayedWorkQueue")]),e._v("的索引，用来快速取消。")])]),e._v(" "),v("h5",{attrs:{id:"主要函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要函数"}},[e._v("#")]),e._v(" 主要函数")]),e._v(" "),v("ul",[v("li",[e._v("compareTo：执行顺序的关键，通过对比"),v("code",[e._v("time")]),e._v("，"),v("code",[e._v("sequenceNumber")]),e._v("进行比较。")]),e._v(" "),v("li",[e._v("getDelay：返回剩余的延迟，0 或负数则表示已经过去。")]),e._v(" "),v("li",[v("strong",[e._v("run")]),e._v("：核心函数，如果是周期任务则在执行完后重新设置下次执行的时间，并把当前任务加入到队列中。")])]),e._v(" "),v("h4",{attrs:{id:"delayedworkqueue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#delayedworkqueue"}},[e._v("#")]),e._v(" DelayedWorkQueue")]),e._v(" "),v("blockquote",[v("p",[e._v("一个私有的无界阻塞队列，针对 ScheduledThreadPool 进行特殊处理。主要表现在获取数据时通过"),v("code",[e._v("ScheduledFutureTask#getDelay")]),e._v("来处理。")])]),e._v(" "),v("h5",{attrs:{id:"主要属性-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要属性-2"}},[e._v("#")]),e._v(" 主要属性")]),e._v(" "),v("ul",[v("li",[e._v("leader：下一个任务执行的线程。只有该线程是延时阻塞，其他线程都是无限期等待。在获取完任务后会唤醒一个等待的线程。")]),e._v(" "),v("li",[e._v("available：一个条件信号，在leader发生变更时会发出条件信号。")])]),e._v(" "),v("h5",{attrs:{id:"主要函数-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要函数-2"}},[e._v("#")]),e._v(" 主要函数")]),e._v(" "),v("ul",[v("li",[e._v("take：获取任务，获取不到无限等待。在当前线程不用回收是，线程池通过该方法获取任务。")]),e._v(" "),v("li",[e._v("poll：获取任务，获取不到超时等待。在当前线程可以被回收是，通过该方法获取任务。")]),e._v(" "),v("li",[e._v("offer：添加任务。设置"),v("code",[e._v("ScheduledFutureTask#heapIndex")]),e._v("，"),v("strong",[e._v("并唤醒一个线程获取任务")]),e._v("。")])]),e._v(" "),v("h4",{attrs:{id:"主要函数-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主要函数-3"}},[e._v("#")]),e._v(" 主要函数")]),e._v(" "),v("ul",[v("li",[e._v("decorateTask：可以通过子类来修改运行的任务。")]),e._v(" "),v("li",[e._v("delayedExecute：延时执行任务。")]),e._v(" "),v("li",[e._v("schedule：添加任务，把任务都包装成"),v("code",[e._v("RunnableScheduledFuture")]),e._v("放入到延时队列中。")])])])}),[],!1,null,null,null);v.default=o.exports}}]);