(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{406:function(t,v,i){"use strict";i.r(v);var r=i(28),a=Object(r.a)({},(function(){var t=this,v=t.$createElement,i=t._self._c||v;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"简介"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),i("ul",[i("li",[i("p",[i("strong",[t._v("它基于动态代理来实现")]),t._v("。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。")])]),t._v(" "),i("li",[i("p",[i("strong",[t._v("Spring 3.2 以后，spring-core 直接就把 CGLIB 和 ASM 的源码包括进来了")])])]),t._v(" "),i("li",[i("p",[t._v("Spring 的 IOC 容器和 AOP 都很重要，Spring AOP 需要依赖于 IOC 容器来管理。")])]),t._v(" "),i("li",[i("p",[t._v("Spring AOP 只能作用于 Spring 容器中的 Bean，它是使用纯粹的 Java 代码实现的，只能作用于 bean 的方法。")])]),t._v(" "),i("li",[i("p",[t._v("Spring 提供了 AspectJ 的支持，但只用到的AspectJ的切点解析和匹配。")])]),t._v(" "),i("li",[i("p",[t._v("Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好。")])])]),t._v(" "),i("h2",{attrs:{id:"概念"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),i("ul",[i("li",[t._v("pointcut：切点，需要插入增强的连接点")]),t._v(" "),i("li",[t._v("Joinpoint：连接点，可以插入的增强位置，在spring中连接点为方法调用")]),t._v(" "),i("li",[t._v("advice：通知，描述如何增强")]),t._v(" "),i("li",[t._v("aspect：切面，通知和切点的结合")])]),t._v(" "),i("h3",{attrs:{id:"advice"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#advice"}},[t._v("#")]),t._v(" advice")]),t._v(" "),i("p",[t._v("Advised")]),t._v(" "),i("p",[t._v("Advisor")]),t._v(" "),i("p",[t._v("Interceptor")])])}),[],!1,null,null,null);v.default=a.exports}}]);