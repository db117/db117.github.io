(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{315:function(t,a,e){"use strict";e.r(a);var r=e(10),_=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#abstractqueuedsynchronizer"}},[t._v("AbstractQueuedSynchronizer")]),a("ul",[a("li",[a("a",{attrs:{href:"#特性"}},[t._v("特性")])]),a("li",[a("a",{attrs:{href:"#关键字段"}},[t._v("关键字段")])]),a("li",[a("a",{attrs:{href:"#扩展方法"}},[t._v("扩展方法")])]),a("li",[a("a",{attrs:{href:"#队列"}},[t._v("队列")])])])]),a("li",[a("a",{attrs:{href:"#reentrantlock"}},[t._v("ReentrantLock")]),a("ul",[a("li",[a("a",{attrs:{href:"#synchronized对比"}},[t._v("synchronized对比")])])])]),a("li",[a("a",{attrs:{href:"#condition"}},[t._v("Condition")])]),a("li",[a("a",{attrs:{href:"#semaphore"}},[t._v("Semaphore")])]),a("li",[a("a",{attrs:{href:"#countdownlatch"}},[t._v("CountDownLatch")])]),a("li",[a("a",{attrs:{href:"#cyclicbarrier"}},[t._v("CyclicBarrier")])]),a("li",[a("a",{attrs:{href:"#reentrantreadwritelock"}},[t._v("ReentrantReadWriteLock")])])])]),t._v(" "),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#abstractqueuedsynchronizer"}},[t._v("AbstractQueuedSynchronizer")]),a("ul",[a("li",[a("a",{attrs:{href:"#特性"}},[t._v("特性")])]),a("li",[a("a",{attrs:{href:"#关键字段"}},[t._v("关键字段")])]),a("li",[a("a",{attrs:{href:"#扩展方法"}},[t._v("扩展方法")])]),a("li",[a("a",{attrs:{href:"#队列"}},[t._v("队列")])])])]),a("li",[a("a",{attrs:{href:"#reentrantlock"}},[t._v("ReentrantLock")]),a("ul",[a("li",[a("a",{attrs:{href:"#synchronized对比"}},[t._v("synchronized对比")])])])]),a("li",[a("a",{attrs:{href:"#condition"}},[t._v("Condition")])]),a("li",[a("a",{attrs:{href:"#semaphore"}},[t._v("Semaphore")])]),a("li",[a("a",{attrs:{href:"#countdownlatch"}},[t._v("CountDownLatch")])]),a("li",[a("a",{attrs:{href:"#cyclicbarrier"}},[t._v("CyclicBarrier")])]),a("li",[a("a",{attrs:{href:"#reentrantreadwritelock"}},[t._v("ReentrantReadWriteLock")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"abstractqueuedsynchronizer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#abstractqueuedsynchronizer"}},[t._v("#")]),t._v(" AbstractQueuedSynchronizer")]),t._v(" "),a("blockquote",[a("p",[t._v("java.util.concurrent包中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这些行为的抽象就是基于 AbstractQueuedSynchronizer（简称AQS）实现的，AQS是一个抽象同步框架，可以用来实现一个依赖状态的同步器。")]),t._v(" "),a("p",[t._v("是一个 Java 层面实现的"),a("strong",[t._v("管程")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特性"}},[t._v("#")]),t._v(" 特性")]),t._v(" "),a("ul",[a("li",[t._v("阻塞等待队列")]),t._v(" "),a("li",[t._v("共享/独占")]),t._v(" "),a("li",[t._v("公平/非公平")]),t._v(" "),a("li",[t._v("可重入")]),t._v(" "),a("li",[t._v("允许中断")])]),t._v(" "),a("h3",{attrs:{id:"关键字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键字段"}},[t._v("#")]),t._v(" 关键字段")]),t._v(" "),a("ul",[a("li",[t._v("state：表示资源可用状态，在不同的子类中有不同的含义。")]),t._v(" "),a("li",[t._v("head ：同步队列头结点")]),t._v(" "),a("li",[t._v("tail：同步队列尾节点")])]),t._v(" "),a("h3",{attrs:{id:"扩展方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#扩展方法"}},[t._v("#")]),t._v(" 扩展方法")]),t._v(" "),a("blockquote",[a("p",[t._v("需要子类实现。")])]),t._v(" "),a("ul",[a("li",[t._v("isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现 它。")]),t._v(" "),a("li",[t._v("tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。")]),t._v(" "),a("li",[t._v("tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。")]),t._v(" "),a("li",[t._v("tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但 没有剩余可用资源；正数表示成功，且有剩余资源。")]),t._v(" "),a("li",[t._v("tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待 结点返回true，否则返回false。")])]),t._v(" "),a("h3",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),a("h4",{attrs:{id:"节点-node"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点-node"}},[t._v("#")]),t._v(" 节点 node")]),t._v(" "),a("h5",{attrs:{id:"关键属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键属性"}},[t._v("#")]),t._v(" 关键属性")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("waitStatus")]),t._v("：节点状态\n"),a("ul",[a("li",[t._v("0：初始状态，表示当前节点在队列中，等待获取锁")]),t._v(" "),a("li",[a("strong",[t._v("CANCELLED")]),t._v("：1。表示当前线程被取消")]),t._v(" "),a("li",[a("strong",[t._v("SIGNAL")]),t._v("：-1。表示当前节点的后续节点需要被唤醒。")]),t._v(" "),a("li",[a("strong",[t._v("CONDITION")]),t._v("：-2。表示当前节点在等待 condition，即在等待队列中。")]),t._v(" "),a("li",[a("strong",[t._v("PROPAGATE")]),t._v("：-3。表示后续的共享节点可以继续执行。")])])]),t._v(" "),a("li",[t._v("prev：前置节点")]),t._v(" "),a("li",[t._v("next：后置节点")]),t._v(" "),a("li",[t._v("thread：节点代表的线程")]),t._v(" "),a("li",[t._v("nextWaiter：等待队列")])]),t._v(" "),a("h4",{attrs:{id:"节点状态变更流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#节点状态变更流程图"}},[t._v("#")]),t._v(" 节点状态变更流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61b076ac0791297e6083896a"}}),t._v(" "),a("h4",{attrs:{id:"同步等待队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步等待队列"}},[t._v("#")]),t._v(" 同步等待队列")]),t._v(" "),a("blockquote",[a("p",[t._v("AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明\n的一种基于双向链表数据结构的队列，是FIFO先进先出线程等待队列，Java中的CLH队列是原\nCLH队列的一个变种,线程由原自旋机制改为阻塞机制。主要用于维护获取锁失败时入队的线程。")])]),t._v(" "),a("h4",{attrs:{id:"条件等待队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件等待队列"}},[t._v("#")]),t._v(" 条件等待队列")]),t._v(" "),a("blockquote",[a("p",[t._v("调用"),a("code",[t._v("await()")]),t._v("的时候会释放锁，然后线程会加入到条件队列，调用 "),a("code",[t._v("signal()")]),t._v("唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁")])]),t._v(" "),a("h4",{attrs:{id:"propagate状态理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#propagate状态理解"}},[t._v("#")]),t._v(" PROPAGATE状态理解")]),t._v(" "),a("blockquote",[a("p",[t._v("http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?r1=1.73&r2=1.74")]),t._v(" "),a("p",[t._v("简单说就是为了解决 bug 添加的。")]),t._v(" "),a("p",[t._v("jdk17 把这个状态给删了。")])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"reentrantlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[t._v("#")]),t._v(" ReentrantLock")]),t._v(" "),a("blockquote",[a("p",[t._v("ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手\n段，它的功能类似于synchronized是一种互斥锁，可以保证线程安全。")])]),t._v(" "),a("h3",{attrs:{id:"synchronized对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#synchronized对比"}},[t._v("#")]),t._v(" synchronized对比")]),t._v(" "),a("ul",[a("li",[t._v("可中断，"),a("code",[t._v("lockInterruptibly")]),t._v("可以被中断")]),t._v(" "),a("li",[t._v("可设置超时时间")]),t._v(" "),a("li",[t._v("可设置为公平锁，"),a("code",[t._v("synchronized")]),t._v("只能是非公平锁")]),t._v(" "),a("li",[t._v("支持多个等待条件")]),t._v(" "),a("li",[t._v("可判断获取锁状态，"),a("code",[t._v("isLocked")])]),t._v(" "),a("li",[t._v("需要开发者在 finally 中释放锁。"),a("code",[t._v("synchronized")]),t._v("会自动释放。")])]),t._v(" "),a("h4",{attrs:{id:"reentrantlock流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock流程图"}},[t._v("#")]),t._v(" ReentrantLock流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61a9d9b10791293428031a40"}}),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"condition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#condition"}},[t._v("#")]),t._v(" Condition")]),t._v(" "),a("blockquote",[a("p",[t._v("条件队列，在"),a("code",[t._v("ReentrantLock")]),t._v("和"),a("code",[t._v("ReentrantReadWriteLock")]),t._v("中使用。")]),t._v(" "),a("p",[t._v("条件队列仅仅是一个等待队列，获取锁的流程还是在阻塞队列的流程中，即通过子类实现的方法中。")]),t._v(" "),a("p",[a("code",[t._v("await")]),t._v(" 就是把添加 "),a("code",[t._v("node")]),t._v(" 节点到条件队列中去，"),a("code",[t._v("signal")]),t._v(" 就是把 "),a("code",[t._v("node")]),t._v(" 节点从条件队列移入到等待队列中。")])]),t._v(" "),a("h4",{attrs:{id:"条件等待队列流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#条件等待队列流程图"}},[t._v("#")]),t._v(" 条件等待队列流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61a9f25f63768928167810f6"}}),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"semaphore"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[t._v("#")]),t._v(" Semaphore")]),t._v(" "),a("blockquote",[a("p",[t._v("用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。")]),t._v(" "),a("p",[t._v("常见于限流，资源池等。")]),t._v(" "),a("p",[t._v("是 aqs 的一个简单实现。")])]),t._v(" "),a("h4",{attrs:{id:"信号量流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号量流程图"}},[t._v("#")]),t._v(" 信号量流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61add0830791296ac4dcf645"}}),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"countdownlatch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[t._v("#")]),t._v(" CountDownLatch")]),t._v(" "),a("blockquote",[a("p",[t._v("是一个同步协助类，允许一个或多个线程等待，直到其他线程完成操作集。")]),t._v(" "),a("p",[t._v("简单来说就是开始设置一个值，通过"),a("code",[t._v("countDown")]),t._v("进行减一操作，到 0 的时候所有通过"),a("code",[t._v("await")]),t._v("进行等待的线程全部开始执行。")])]),t._v(" "),a("h4",{attrs:{id:"countdownlatch与thread-join的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch与thread-join的区别"}},[t._v("#")]),t._v(" CountDownLatch与Thread.join的区别")]),t._v(" "),a("ul",[a("li",[t._v("CountDownLatch的作用就是允许一个或多个线程等待其他线程完成操作，看起来有点类似join() 方法，但其提供了比 join() 更加灵活的API。")]),t._v(" "),a("li",[t._v("CountDownLatch可以手动控制在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。")]),t._v(" "),a("li",[t._v("join() 的实现原理是不停检查join线程是否存活，如果 join 线程存活则让当前线程永远等待。所以两者之间相对来说还是CountDownLatch使用起来较为灵活。")])]),t._v(" "),a("h4",{attrs:{id:"countdownlatch与cyclicbarrier的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch与cyclicbarrier的区别"}},[t._v("#")]),t._v(" CountDownLatch与CyclicBarrier的区别")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("CountDownLatch")]),t._v("的计数器只能使用一次，而"),a("code",[t._v("CyclicBarrier")]),t._v("的计数器可以使用"),a("code",[t._v("reset()")]),t._v(" 方法重置。所以"),a("code",[t._v("CyclicBarrier")]),t._v("能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("CyclicBarrier")]),t._v("还提供"),a("code",[t._v("getNumberWaiting")]),t._v("(可以获得"),a("code",[t._v("CyclicBarrier")]),t._v("阻塞的线程数量)、 "),a("code",[t._v("isBroken")]),t._v("(用来知道阻塞的线程是否被中断)等方法。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("CountDownLatch")]),t._v("和"),a("code",[t._v("CyclicBarrier")]),t._v("都能够实现线程之间的等待，只不过它们侧重点不 同。"),a("code",[t._v("CountDownLatch")]),t._v("一般用于一个或多个线程，等待其他线程执行完任务后，再执行。"),a("code",[t._v("CyclicBarrier")]),t._v("一般用于一组线程互相等待至某个状态，然后这一组线程再同时执 行。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("CyclicBarrier")]),t._v(" 还可以提供一个 "),a("code",[t._v("barrierAction")]),t._v("，合并多线程计算结果。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("CyclicBarrier")]),t._v("是通过"),a("code",[t._v("ReentrantLock")]),t._v('的"独占锁"和'),a("code",[t._v("Conditon")]),t._v("来实现一组线程的阻塞唤 醒的，而"),a("code",[t._v("CountDownLatch")]),t._v("则是通过"),a("code",[t._v("AQS")]),t._v("的“共享锁”实现")])])]),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"cyclicbarrier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[t._v("#")]),t._v(" CyclicBarrier")]),t._v(" "),a("blockquote",[a("p",[t._v("翻译为循环屏障或回环栅栏。通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被"),a("strong",[t._v("重用")]),t._v("。")])]),t._v(" "),a("h4",{attrs:{id:"主要属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要属性"}},[t._v("#")]),t._v(" 主要属性")]),t._v(" "),a("ul",[a("li",[t._v("lock：除"),a("code",[t._v("getParties")]),t._v("外所有操作都需要持有该锁")]),t._v(" "),a("li",[t._v("trip：等待条件，除最后一个任务外都会"),a("code",[t._v("trip.await()")]),t._v("进行等待")]),t._v(" "),a("li",[t._v("parties：等待的线程数量")]),t._v(" "),a("li",[t._v("barrierCommand：最后一个到达的线程会执行该任务（有的话），执行完才放行")]),t._v(" "),a("li",[t._v("Generation：屏障实例，每一次都是一个新的。")]),t._v(" "),a("li",[t._v("count：剩余需要阻塞的线程数量")])]),t._v(" "),a("h4",{attrs:{id:"循环屏障流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#循环屏障流程图"}},[t._v("#")]),t._v(" 循环屏障流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61aec9dd0e3e74014814eb94"}}),t._v(" "),a("hr"),t._v(" "),a("h2",{attrs:{id:"reentrantreadwritelock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reentrantreadwritelock"}},[t._v("#")]),t._v(" ReentrantReadWriteLock")]),t._v(" "),a("blockquote",[a("p",[t._v("读写锁，适合读多写少的场景")]),t._v(" "),a("p",[t._v("使用 Sync ( 实际是 AQS )的 int 类型的 state 来表示同步状态，维护着一对读写锁，如果要用一个变量维护多种状态，需要采用“按位切割使用”的方式来维护这个变量，将其切分为两部分：高16为表示读，低16为表示写。")])]),t._v(" "),a("h4",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ul",[a("li",[t._v("读写互斥")]),t._v(" "),a("li",[t._v("写写互斥")]),t._v(" "),a("li",[t._v("可重入")]),t._v(" "),a("li",[t._v("支持公平与非公平")]),t._v(" "),a("li",[t._v("支持条件队列")]),t._v(" "),a("li",[t._v("提供一下锁状态监控api")]),t._v(" "),a("li",[t._v("读锁不支持等待队列")]),t._v(" "),a("li",[t._v("重入不能升级，持有读锁的情况下去获取写锁会导致获取永久等待")]),t._v(" "),a("li",[t._v("可支持锁降级，在获取写锁时获取读锁、然后释放写锁，则降级为读锁")])]),t._v(" "),a("h4",{attrs:{id:"读写锁流程图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#读写锁流程图"}},[t._v("#")]),t._v(" 读写锁流程图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"725px",height:"245px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/61af0642e0b34d775429161c"}})])}),[],!1,null,null,null);a.default=_.exports}}]);