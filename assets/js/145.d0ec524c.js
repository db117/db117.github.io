(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{420:function(s,e,t){"use strict";t.r(e);var n=t(10),a=Object(n.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("blockquote",[e("p",[s._v("一个在 Java 单元测试中模拟校验数据的框架")]),s._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/mockito/mockito",target:"_blank",rel:"noopener noreferrer"}},[s._v("mockito/mockito: Most popular Mocking framework for unit tests written in Java (github.com)"),e("OutboundLink")],1)]),s._v(" "),e("p",[e("a",{attrs:{href:"https://site.mockito.org/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Mockito framework site"),e("OutboundLink")],1)])]),s._v(" "),e("h3",{attrs:{id:"使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[s._v("#")]),s._v(" 使用")]),s._v(" "),e("h4",{attrs:{id:"mock-和-spy-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mock-和-spy-区别"}},[s._v("#")]),s._v(" mock 和 spy 区别")]),s._v(" "),e("ul",[e("li",[s._v("mock 出的对象是 null 的上面都没有，没有插桩返回默认值")]),s._v(" "),e("li",[s._v("spy 出的对象是真实的对象、在没有插桩的情况下执行真实的方法")]),s._v(" "),e("li",[s._v("spy 在执行 "),e("code",[s._v("when().return()")]),s._v("时会先执行真实方法,再执行插桩的方法,需用 "),e("code",[s._v("doReturn().when()")])]),s._v(" "),e("li",[e("code",[s._v("Answer")]),s._v("和"),e("code",[s._v("Throw")]),s._v("同上")])]),s._v(" "),e("h4",{attrs:{id:"模拟数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模拟数据"}},[s._v("#")]),s._v(" 模拟数据")]),s._v(" "),e("blockquote",[e("p",[s._v("有多种方式实现，但是常用注解方式。")])]),s._v(" "),e("p",[s._v("在需要插桩的对象、接口上面添加注解"),e("code",[s._v("@Mock")]),s._v("、"),e("code",[s._v("@Spy")]),s._v("、"),e("code",[s._v("Captor")]),s._v("，在需要测试的对象上添加注解"),e("code",[s._v("@InjectMocks")]),s._v("然后调用"),e("code",[s._v("MockitoAnnotations#openMocks()")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues#returnValueFor\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h4",{attrs:{id:"常用api"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[s._v("#")]),s._v(" 常用api")]),s._v(" "),e("ul",[e("li",[s._v("mock\n"),e("ul",[e("li",[s._v("参数带 "),e("code",[s._v("Class")]),s._v(" 的是通过参数来获取具体对象类型的")]),s._v(" "),e("li",[s._v("参数没有带 "),e("code",[s._v("Class")]),s._v(" 的是用来返回值的泛型来获取对象类型的")])])]),s._v(" "),e("li",[s._v("mockConstruction\n"),e("ul",[e("li",[s._v("模拟构造函数，很少使用")])])]),s._v(" "),e("li",[s._v("mockStatic\n"),e("ul",[e("li",[s._v("模拟静态方法")])])]),s._v(" "),e("li",[s._v("spy\n"),e("ul",[e("li",[s._v("模拟对象，再没有插桩下调用的是真实方法")]),s._v(" "),e("li",[s._v("spy 在执行 "),e("code",[s._v("when().return()")]),s._v("时会先执行真实方法,再执行插桩的方法,需用 "),e("code",[s._v("doReturn().when()")])])])]),s._v(" "),e("li",[s._v("when\n"),e("ul",[e("li",[s._v("核心api，开启插桩。")])])])]),s._v(" "),e("h5",{attrs:{id:"执行插桩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行插桩"}},[s._v("#")]),s._v(" 执行插桩")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("doReturn")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("最常用的方法，模拟返回值。")])]),s._v(" "),e("li",[e("p",[s._v("可以传入多个返回值，依次返回。")])]),s._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('\t\tdoReturn("foo", "bar")\n                .doThrow(new RuntimeException())\n                .doReturn(430L, new byte[0], "qix")\n                .when(mock)\n                .objectReturningMethodNoArgs();\n\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("foo");\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("bar");\n        try {\n            mock.objectReturningMethodNoArgs();\n            fail("exception not raised");\n        } catch (RuntimeException expected) {\n        }\n\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(430L);\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo(new byte[0]);\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");\n        assertThat(mock.objectReturningMethodNoArgs()).isEqualTo("qix");\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br")])])])])]),s._v(" "),e("li",[e("p",[s._v("​\tdoThrow")]),s._v(" "),e("ul",[e("li",[s._v("同 doReturn")])])]),s._v(" "),e("li",[e("p",[s._v("doNothing")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("常见于"),e("code",[s._v("void")]),s._v("返回值的方法，模拟一次调用。")])]),s._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("   doNothing().\n   doThrow(new RuntimeException())\n   .when(mock).returnVoidMethod();\n\n   // 第一次调用，什么都没有执行\n   mock.returnVoidMethod();\n\n   // 第二次抛出异常\n   mock.returnVoidMethod();\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])])])])]),s._v(" "),e("li",[e("p",[s._v("doCallRealMethod")]),s._v(" "),e("ul",[e("li",[s._v("调用真实方法，只有在历史代码上面才会这么干。属于填坑")])])]),s._v(" "),e("li",[e("p",[s._v("doAnswer")]),s._v(" "),e("ul",[e("li",[s._v("通过"),e("code",[s._v("org.mockito.stubbing.Answer")]),s._v("构造返回值")]),s._v(" "),e("li",[s._v("再模拟返回 "),e("code",[s._v("void")]),s._v("的方法时需要返回 null")])])])]),s._v(" "),e("h5",{attrs:{id:"验证"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#验证"}},[s._v("#")]),s._v(" 验证")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("after")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("需要在后面接上验证模式")])]),s._v(" "),e("li",[e("p",[s._v("在指定时间内进行校验，如果校验失败则直接抛出异常")])]),s._v(" "),e("li",[e("p",[s._v("在指定时间结束时，未满足条件也会抛出异常")])]),s._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("   // 100ms 内，被调用 1 次\n   verify(mock, after(100)).someMethod();\n   // 100ms 内，被调用 1 次\n   verify(mock, after(100).times(1)).someMethod();\n\n   // 100ms 内，被调用 2 次\n   verify(mock, after(100).times(2)).someMethod();\n\n   // 100ms 内，被调用 0 次\n   verify(mock, after(100).never()).someMethod();\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br")])])])])]),s._v(" "),e("li",[e("p",[s._v("timeout")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("使用方式和"),e("code",[s._v("after")]),s._v("一样")])]),s._v(" "),e("li",[e("p",[s._v("但是timeout再满足条件后直接返回"),e("code",[s._v("success")]),s._v("，但是"),e("code",[s._v("after")]),s._v("需要等到时间结束才返回")])]),s._v(" "),e("li",[e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("   //1.\n   mock.foo();\n   verify(mock, after(1000)).foo();\n   // 等 1000 ms\n\n   //2.\n   mock.foo();\n   verify(mock, timeout(1000)).foo();\n   // 直接返回\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])])])])]),s._v(" "),e("li",[e("p",[s._v("atLeast，atLeastOnce")]),s._v(" "),e("ul",[e("li",[s._v("最少调用次数")])])]),s._v(" "),e("li",[e("p",[s._v("atMostOnce，atMost")]),s._v(" "),e("ul",[e("li",[s._v("最多调用次数")])])]),s._v(" "),e("li",[e("p",[s._v("times")]),s._v(" "),e("ul",[e("li",[s._v("指定调用次数")])])]),s._v(" "),e("li",[e("p",[s._v("only")]),s._v(" "),e("ul",[e("li",[s._v("是否是唯一调用的方法")]),s._v(" "),e("li",[s._v("和"),e("code",[s._v("verifyNoMoreInteractions")]),s._v("有相同的功能。")])])]),s._v(" "),e("li",[e("p",[s._v("verifyNoInteractions")]),s._v(" "),e("ul",[e("li",[s._v("验证没有插桩的方法被调用")])])]),s._v(" "),e("li",[e("p",[s._v("verifyNoMoreInteractions")]),s._v(" "),e("ul",[e("li",[s._v("验证没有非插桩方法被调用")])])]),s._v(" "),e("li",[e("p",[s._v("inOrder")]),s._v(" "),e("ul",[e("li",[s._v("验证方法调用顺序")])])]),s._v(" "),e("li",[e("p",[s._v("calls")]),s._v(" "),e("ul",[e("li",[s._v("指定调用次数")]),s._v(" "),e("li",[s._v("只能在"),e("code",[s._v("inOrder")]),s._v("使用")])])])]),s._v(" "),e("h5",{attrs:{id:"参数捕捉"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参数捕捉"}},[s._v("#")]),s._v(" 参数捕捉")]),s._v(" "),e("blockquote",[e("p",[s._v("使用"),e("code",[s._v("@Captor")]),s._v("标记在"),e("code",[s._v("ArgumentCaptor")]),s._v("上。")]),s._v(" "),e("p",[s._v("在每一个插桩的方法都有一个栈来保存方法执行的参数，参数捕捉就是直接获取栈顶的数据。")])]),s._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[s._v('     @Captor ArgumentCaptor<Person> captor;\n     \n     // when\n     createPerson("Wes", "Williams");\n        \n    // then\n    ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);\n    verify(peopleRepository).save(captor.capture());\n    assertEquals("Wes", captor.getValue().getName());\n    assertEquals("Williams", captor.getValue().getSurname());\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);